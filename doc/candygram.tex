\documentclass{howto}
\title{Candygram}
\makeindex
\date{\today}
\author{Michael Hobbs}
\authoraddress{
        Email: \email{mike@hobbshouse.org}
}
\release{1.0 beta 1}
\setshortversion{1.0}

\newcommand{\Erlang}{\ulink{Erlang}{http://www.erlang.org/}}
\newcommand{\erlangbook}{\citetitle[http://www.erlang.org/download/erlang-book-part1.pdf]{Concurrent Programming in Erlang}}

% PDF output doesn't display some symbols well, unless it is in math mode.
% The math mode graphics generated by latex2html, on the other hand, look awful.
\ifpdf
 	\newcommand{\lessthan}[0]{\begin{math}<\end{math}}
 	\newcommand{\greaterthan}[0]{\begin{math}>\end{math}}
 	\newcommand{\pipe}[0]{\begin{math}|\end{math}}
\else
 	\newcommand{\lessthan}[0]{<}
 	\newcommand{\greaterthan}[0]{>}
 	\newcommand{\pipe}[0]{|}
\fi



\begin{document}

\maketitle

Copyright \copyright\ 2004 Michael Hobbs.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled ``GNU
Free Documentation License''.

\begin{abstract}
\noindent
Candygram is a Python implementation of \Erlang\ concurrency primitives. Erlang
is widely respected for its elegant built-in facilities for concurrent
programming. This package attempts to emulate those facilities as closely as
possible in Python. Specifically, this package provides functions that allow
developers to send and receive messages between threads using semantics nearly
identical to those in the Erlang language.
\end{abstract}

\tableofcontents



% ############################################################################
\section{Download And Install}

All available versions of Candygram can be \ulink{downloaded here}
	{http://sourceforge.net/project/showfiles.php?group_id=114295} on
SourceForge.net. The current stable release, as of this writing, is \version.
This documentation can also be downloaded in PDF format from the link above.

To install, uncompress the zip or tar file, \program{cd} into the directory, and
run:
\begin{verbatim}
python setup.py install
\end{verbatim}

Windows users can just download the installer program and run it.



% ############################################################################
\section{Overview}

\begin{notice}[note]
Erlang uses a peculiar terminology in respect to threads. In Erlang parlance,
threads are called ``processes''. This terminology is due to a couple of
reasons. First, the Erlang runtime environment is a virtual machine. Second,
because Erlang is a functional language, no state is shared among its threads.
Since the concurrent tasks in an Erlang system run as peers within a single
[virtual] machine and don't share state, they are therefore named ``Processes''.

In order to avoid confusion when using this documentation alongside the Erlang
documentation, the word ``process'' is used instead of ``thread'' throughout the
remainder of this document. You are free to pronounce the word ``process''
however you wish.
\end{notice}

This package provides an implementation of the following \Erlang\ core
functions:
\begin{itemize}
	\item \function{spawn()}
	\item \function{send()}
	\item \keyword{receive}
	\item \function{link()}
\end{itemize}

These 4 functions form the core of Erlang's concurrency services. The
\function{spawn()} function creates a new process, the \function{send()}
function will send a message to another process, the \keyword{receive} statement
specifies what to do with received messages, and the \function{link()} function
allows one process to monitor the status of another process. In addition to
these core functions, this package also provides implementations of several
supplemental functions such as \function{spawn_link()} and \function{exit()}.

The beauty of the Erlang system is that it is simple and yet powerful.
To communicate with another process, you simply send a message to it.
You need not worry about locks, semaphores, mutexes, etc., in order to
share information among concurrent tasks. Even though message passing is
typically used to implement the producer/consumer model, when it is combined
with the flexibility of the \keyword{receive} statement, it becomes much more
powerful. For example, when using timeouts and selective receives, a process
may easily handle its messages as a state machine, or as a priority queue.

For those who wish to become more familiar with Erlang, \erlangbook\ provides a
very complete introduction. In particular, this package implements all of the
functions described in chapter 5 and sections 7.2, 7.3, and 7.5 of that book.



% ############################################################################
\section{Receiver Patterns}
\label{patterns}
\index{patterns}

\newcommand{\addhandler}{\method{addHandler()}}

Erlang provides pattern matching in its very syntax, which is then used by the
\keyword{receive} statement. Since Python does not provide pattern matching in
its syntax, we must use a slightly different mechanism to match messages. The
first parameter passed to the \method{Receiver.addHandler()} method
[\ref{Receiver}] can be any Python value. The \addhandler\ method uses this
value as a pattern and interprets it in the following way:
\begin{enumerate}
	\item If the value is \constant{candygram.Any}, then any message will match.
	\item If the value is a class object or a type object, then any message that
		\function{isinstance()} of the class or type will match.
	\item If the value is a function or method, then a message will match if the
		function/method returns \constant{True} when called with the message.
	\item If the value is a list or tuple, then a message will match only if it
		is a list or tuple, respectively, and of the same length. Also, each value
		in the sequence is then used as a pattern and the sequence as a whole will
		match only if every pattern in the sequence matches.
	\item If the value is a list or tuple, and the last item in the sequence is
		\constant{candygram.AnyRemaining}, then the above rules apply except that
		the message sequence may be any length that is \greaterthan= len(pattern)-1.
	\item If the value is a dictionary, then a message will match only if it
		is a dictionary that contains all of the same keys as the pattern value.
		Also, each value in the dictionary is then used and a pattern and the
		dictionary as a whole will match only if every pattern in the dictionary
		matches its associated value in the message.
	\item Lastly, any other value is treated as a literal pattern. That is, a
		message will match if it is equal to the given value.
\end{enumerate}

\subsection{Examples}
These rules are best illustrated by example. In the table below, the first
column contains a Python value that is used as a pattern. The second column
contains Python values that would match the pattern and the third column
contains Python values that would not match the pattern.
\begin{tableiii}{l|l|l}{textrm}{Pattern}{Matches}{Non-Matches}
\lineiii{Any}
	{'shark', 13.7, (1, '', lambda: true)}
	{}
\lineiii{'shark'}
	{'shark'}
	{'dolphin', 42, []}
\lineiii{13.7}
	{13.7}
	{'shark', 13.6, \{'A': 14\}}
\lineiii{int}
	{13, 42, 0}
	{'shark', 13.7, []}
\lineiii{str}
	{'shark', '', 'dolphin'}
	{42, 0.9, lambda: true}
\lineiii{lambda x: x \greaterthan\ 20}
	{42, 100, 67.7}
	{13, 0, -67.7}
\lineiii{(str, int)}
	{('shark', 42), ('dolphin', 0)}
	{['shark', 42], ('dolphin', 42, 0.9)}
\lineiii{(str, int, AnyRemaining)}
	{('dolphin', 0), ('dolphin', 42, 0.9)}
	{('dolphin',), (42, 'dolphin')}
\lineiii{[str, 20, lambda x: x \lessthan\ 0]}
	{['shark', 20, -54.76], ['dolphin', 20, -1]}
	{['shark', 21, -6], [20, 20, -1], ['', 20]}
\lineiii{\{'S': int, 19: str\}}
	{\{'S': 3, 19: 'foo'\}, \{'S': -65, 19: 'bar', 'T': 'me'\}}
	{\{'S': 'Charlie', 19: 'foo'\}, \{'S': 3\}}
\end{tableiii}



% ############################################################################
\section{The \module{candygram} module}

\declaremodule{extension}{candygram}
\modulesynopsis{Erlang concurrency primitives}

The following functions, classes, and constants are exported by the
\module{candygram} module. Since the name \module{candygram} is a bit long, the
module is typically imported in one of the following ways:
\begin{verbatim}
>>> from candygram import *
\end{verbatim}
or
\begin{verbatim}
>>> import candygram as cg
\end{verbatim}



% ----------------------------------------------------------------------------
\subsection{Functions}

\begin{funcdesc}{spawn}{func\optional{, args\moreargs}}
Return the \class{Process} instance of a new concurrent process started by
calling the function \var{func} with the \var{args} argument list. When the
function returns, the process terminates. A \code{'badarg'}
\exception{ExitError} is raised if \var{func} is not \function{callable()}.
\end{funcdesc}

\begin{funcdesc}{link}{proc}
Create a link to the process \var{proc}, if there is not such a link already. If
a process attempts to create a link to itself, nothing is done. A
\code{'badarg'} \exception{ExitError} is raised if \var{proc} is not a
\class{Process} instance. A \code{'noproc'} \code{'EXIT'} signal is sent to
calling process if the \var{proc} process is no longer alive.

When a process terminates, an \code{'EXIT'} signal is sent to all of its linked
processes. If a process terminates normally, a \code{'normal'} \code{'EXIT'}
signal is sent to its linked processes.

All links are bidirectional. That is, if process A calls \code{link(B)}, then if
process B terminates, an \code{'EXIT'} signal is sent to process A. Conversely,
if process A terminates, an \code{'EXIT'} signal is likewise sent to process B.

Refer to the \function{processFlag()} function for details about handling
signals.
\end{funcdesc}

\begin{funcdesc}{spawnLink}{func\optional{, args\moreargs}}
This function is identical to the following code being evaluated in an atomic
operation:
\begin{verbatim}
>>> proc = spawn(func, args...)
>>> link(proc)
\end{verbatim}
This function is necessary since the process created might run immediately and
fail before \function{link()} is called. Returns the \class{Process} instance of
the newly created process. A \code{'badarg'} \exception{ExitError} is raised if
\var{func} is not \function{callable()}.
\end{funcdesc}

\begin{funcdesc}{unlink}{proc}
Remove the link, if there is one, from the calling process to another process
given by the \var{proc} argument. The function will not fail if the calling
process is not linked to \var{proc}, or if \var{proc} is not alive. A
\code{'badarg'} \exception{ExitError} is raised if \var{proc} is not a
\class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{isProcessAlive}{proc}
Return \constant{True} if the process is alive, i.e., has not terminated.
Otherwise, return \constant{False}. A \code{'badarg'} \exception{ExitError} is
raised if \var{proc} is not a \class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{self}{}
Return the \class{Process} instance of the calling process.
\end{funcdesc}

\begin{funcdesc}{self_}{}
An alias for the \function{self()} function. This function can be used used in
class methods where \var{self} is already defined.
\end{funcdesc}

\begin{funcdesc}{processes}{}
Return a list of all active processes.
\end{funcdesc}

\begin{funcdesc}{send}{proc, message}
Send the \var{message} to the \var{proc} process and return \var{message}. This
is the same as \var{proc}\code{.send(}\var{message}\code{)}. A \code{'badarg'}
\exception{ExitError} is raised if \var{proc} is not a \class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{exit}{\optional{proc, }reason}
When the \var{proc} argument is not given, this function raises an
\exception{ExitError} with the reason \var{reason}. \var{reason} can be any
value.

When the \var{proc} argument is given, this function sends an \code{'EXIT'}
signal to the process \var{proc}. This is not necessarily the same as sending an
\code{'EXIT'} message to \var{proc}. They are the same if \var{proc} is trapping
exits. However, if \var{proc} is not trapping exits, the \var{proc} process will
exit and propagate the \code{'EXIT'} signal in turn to its linked processes.

If the \var{reason} is the string \code{'kill'}, for example
\code{exit(proc, 'kill')}, an untrappable \code{'EXIT'} signal will be sent to
the process. In other words, the \var{proc} process will be unconditionally
killed.

Refer to the \function{processFlag()} function for details about trapping exits.
\end{funcdesc}

\begin{funcdesc}{processFlag}{flag, option}
Set the given \var{flag} for the process which calls this function.
Returns the old value of the flag. A \code{'badarg'} \exception{ExitError} is
raised if \var{flag} is not a recognized flag value, or if \var{option} is not
a recognized value for \var{flag}.

Currently, the only recognized flag value is \code{'trap_exit'}. When
\code{'trap_exit'} is set to \constant{True}, \code{'EXIT'} signals arriving to
a process are converted to \code{('EXIT', from, reason)} messages, which can be
received as ordinary messages. If \code{'trap_exit'} is set to \constant{False},
the process exits if it receives an \code{'EXIT'} signal other than
\code{'normal'} and the \code{'EXIT'} signal is propagated to its linked
processes. Application processes should normally not trap exits.
\end{funcdesc}



% ----------------------------------------------------------------------------
\subsection{Process Objects}

\begin{classdesc}{Process}{}
Represents a concurrent process. A \class{Process} is never created via its
constructor. All processes are created via the \function{spawn()} and
\function{spawnLink()} functions instead.

\begin{methoddesc}{isProcessAlive}{}
Return \constant{True} if the process is alive, i.e., has not terminated.
Otherwise, return \constant{False}.
\end{methoddesc}

\begin{methoddesc}{isAlive}{}
An alias for the \method{isProcessAlive()} method. (The word ``process'' is
redundant in a method name in the \class{Process} class.)
\end{methoddesc}

\begin{methoddesc}{send}{message}
Send the \var{message} to this process and return \var{message}. Typically, a
routine running in a separate process calls this method to place the given
\var{message} into this process's mailbox. The message may then be picked up
by a \class{Receiver} that is operating in this process.

Sending a message is an asynchronous operation so the \method{send()} call will
not wait for the message to be received by a \class{Receiver}. Even if this
process has already terminated, the system will not notify the sender. Messages
are always delivered, and always in the same order they were sent.
\end{methoddesc}

\begin{methoddesc}{__or__}{message}
\opindex{|}
An alias for the \method{send()} method. The OR operator, `\pipe', is aliased to
the \method{send()} method so that messages can be sent using a more Erlangy
syntax. In Erlang, messages are sent using the `!' primitive. For example:
\begin{verbatim}
>>> proc | ('knock-knock', 'candygram')
\end{verbatim}
\end{methoddesc}

\end{classdesc}



% ----------------------------------------------------------------------------
\subsection{Receiver Objects}
\label{Receiver}

\begin{classdesc}{Receiver}{}
Retrieves messages from a process's mailbox. Every process maintains a mailbox,
which contains messages that have been sent to it via the \method{send()}
method. To retrieve the messages out of the mailbox, a process must use a
\class{Receiver} object. Like the \keyword{receive} statement in Erlang, a
\class{Receiver} object will match an incoming message against multiple patterns
[\ref{patterns}] and will then invoke the callback function that is associated
with the matching pattern.

A single \class{Receiver} instance may not be used across multiple processes.
The \class{Receiver} will raise an \exception{AssertionError} if one of its
methods is invoked from a process other than the one that created it. Care
should be taken, therefore, to make sure that a \class{Receiver} is created
within the process that will be using it.

\begin{methoddesc}{addHandler}{pattern\optional{, func\optional{, args\moreargs}}}
Register a handler function \var{func} to be called with the \var{args} argument
list when a message matching \var{pattern} is received. When a handler function
\var{func} is not specified, the \method{receive()} method will remove any
matching messages from the mailbox and do nothing more with them. Refer to
section \ref{patterns} for details about how to specify message patterns. Raises
an \exception{AssertionError} if \var{func} is not \function{callable()}.

If any of the \var{args} parameters is \constant{candygram.Message}, then when
\var{func} is invoked, that parameter is replaced with the message that matched
the pattern.

\note{The handler functions are not invoked until the \method{receive()}
method is called. Refer to the \method{receive()} documentation for details
about the mechanism by which handlers are invoked.}
\end{methoddesc}

\begin{methoddesc}{__setitem__}{pattern, funcWithArgs}
\opindex{[]}
An alias for the \method{addHandler()} method. If \var{funcWithArgs} is a tuple,
then the first element in the tuple is sent as the \var{func} parameter to
\method{addHandler()} and the remaining elements are sent as the \var{args}. If
\var{funcWithArgs} is not a tuple, then it is assumed to be a handler function
and sent as the \var{func} parameter to \method{addHandler()}.

\method{__setitem__()} is aliased to the \method{addHandler()} method so that
handlers can be specified using a more Erlangy syntax. In Erlang, pattern guards
are specified using ``\var{pattern} -\greaterthan\ \var{func}'' syntax. For
example:
\begin{verbatim}
>>> r = Receiver()
>>> r['knock-knock', 'candygram'] = answer, 'From whom?'
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}{__getitem__}{pattern}
\opindex{[]}
An alias for the \method{addHandler()} method. Using \method{__getitem__()} is
equivalent to calling \method{addHandler()} without a \var{func} parameter.

\method{__getitem__()} is aliased to the \method{addHandler()} method so that
handlers can be specified using a more Erlangy syntax. In Erlang, pattern guards
are specified using ``\var{pattern} -\greaterthan\ \var{func}'' syntax. For
example:
\begin{verbatim}
>>> r = Receiver()
>>> r['knock-knock', 'dolphin']  # ignore dolphins
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}{addHandlers}{receiver}
Register all handler functions in \var{receiver} with this \class{Receiver}
object. All patterns and handler functions that have been added to the given
\var{receiver} will be added to this receiver, in the same order. You can use
this method to make copies of \class{Receiver} objects. It is admissible to
use a \var{receiver} that was created in a different process.
\end{methoddesc}

\begin{methoddesc}{after}{timeout\optional{, func\optional{, args\moreargs}}}
Register a timeout handler function \var{func} to be called with the \var{args}
argument list when no matching message is received within \var{timeout}
milliseconds. Raises an \exception{AssertionError} if \var{func} is not
\function{callable()} or if the \method{after()} method has already been
invoked.

If the \method{receive()} method does not find a matching message within
\var{timeout} milliseconds, it will invoke \var{func} with \var{args} and return
the result. When a handler function \var{func} is not specified, the
\method{receive()} method will return \constant{None} if it times out.

None of the \var{args} parameters should be \constant{candygram.Message}, since
there is no message to pass when a timeout occurs.
\end{methoddesc}

\begin{methoddesc}{receive}{\optional{timeout\optional{, func\optional{, args\moreargs}}}}
Find a matching message in the process's mailbox, invoke the related handler
function, and return the result. When the \method{receive()} method is called,
the \class{Receiver} object compares the first message in the process's mailbox
with each of its registered patterns, in the order that the handlers were added
via the \method{addHandler()} method. If any pattern matches the message, the
message is removed from the mailbox and the \method{receive()} method will then
call the associated function and return its result. If no handler function is
associated with the matching pattern, \method{receive()} will return
\constant{None}. If no pattern matches the message, the message is left in the
mailbox and the \method{receive()} method skips to the next message in the
mailbox and compares it with each of the patterns. It continues on through each
of the messages in the mailbox until a match is found.

If no message matches any of the patterns, or if the mailbox is empty, the
\method{receive()} method blocks until the process receives a message that does
match one of the patterns, or until the given \var{timeout} has elapsed. If no
\var{timeout} is specified, the \method{receive()} method will block
indefinitely. If a \var{timeout} is specified, it is equivalent to calling
\method{after(\var{timeout}, \var{func}, \var{args})} just prior to
\method{receive()}. An \exception{AssertionError} will therefore be raised if
\var{func} is not \function{callable()} or if the \method{after()} method has
already been invoked.
\end{methoddesc}

\begin{methoddesc}{__call__}{\optional{timeout\optional{, func\optional{, args\moreargs}}}}
\opindex{()}
An alias for the \method{receive()} method. \method{__call__()} is aliased to
the \method{receive()} method so that \class{Receiver}s can be used with a
shortened, more Erlangy syntax. For example:
\begin{verbatim}
>>> def convert():
...     r = Receiver()
...     r['one'] = lambda: 1
...     r['two'] = lambda: 2
...     r['three'] = lambda: 3
...     return r()
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}{__iter__}{}
Return an iterator that repeatedly invokes \method{receive()}. The following
idiom is often encountered in Candygram code:
\begin{verbatim}
... while True:
...     result = receiver.receive()
...     # do whatever with the result...
\end{verbatim}
With an iterator, the code above can be spelled like this instead:
\begin{verbatim}
... for result in receiver:
...     # do whatever with the result...
\end{verbatim}
\end{methoddesc}

\end{classdesc}



% ----------------------------------------------------------------------------
\subsection{Constants}

\begin{datadesc}{Any}
When used in a pattern, the \constant{Any} constant will match any value.
\end{datadesc}

\begin{datadesc}{AnyRemaining}
When used in the last position of a tuple or list pattern, the
\constant{AnyRemaining} constant will cause the sequence to match a sequence of
the same kind (tuple or list) that has a length \greaterthan= len(pattern)-1.
The patterns in the sequence prior to \constant{AnyRemaining} must still match
their respective values in a message for the whole sequence to match.
\end{datadesc}

\begin{datadesc}{Message}
When used as a function parameter in \method{Receiver.addHandler()}, the
parameter will be replaced by the matching message when the hander function is
invoked.
\end{datadesc}



% ----------------------------------------------------------------------------
\subsection{Exceptions}

\begin{excdesc}{ExitError}
Used to represent \code{'EXIT'} errors in Erlang. If an Erlang function can
cause a failure under certain circumstances, then the corresponding Candygram
function will raise an \exception{ExitError} under the same circumstances.

An \exception{ExitError} will also be raised if a linked process terminates for
a reason other than \code{'normal'}.

\begin{notice}[note]
When a process terminates with a reason other than \code{'normal'}, an
\exception{ExitError} is not immediately raised in all linked processes.
The \exception{ExitError} is deferred instead and will be raised the next time
one of the Candygram functions/methods is called. (Python does not allow you to
unconditionally interrupt a separate thread.)
\end{notice}

\begin{memberdesc}{reason}
A string that specifies the reason why the \exception{ExitError} was raised.
\end{memberdesc}

\begin{memberdesc}{proc}
The process that originally caused the \exception{ExitError}.
\end{memberdesc}

\end{excdesc}



% ############################################################################
\section{Examples}
There should be a directory named \file{examples} somewhere within your
distribution of Candygram. This directory contains the Candygram equivalents of
all the sample programs found in chapter 5 and sections 7.2, 7.3, and 7.5 of
\erlangbook. The files named \file{program_X.X.py} are direct translations of
the Erlang programs. The files named \file{program_X.X_alt.py} are alternate,
more liberal translations that use more Pythonic idioms. \note{Since the
CPython interpreter does not perform tail-call optimization, the tail-recursive
style of the direct translations is not a recommended practice.}

The \file{examples} directory also contains a few other modules that demonstrate
how Candygram can be used to perform some handy functions.

For those who are not already familiar with Erlang, the best way to become
familiar with Candygram is to read chapter 5 in \erlangbook\ and follow along
using the example programs located in the \file{examples} directory. For those
who are already familiar with Erlang, here are a few code snippits to give you a
taste of Candygram.

\begin{verbatim}
>>> from candygram import *
>>> def proc_func():
...     r = Receiver()
...     r['land shark'] = lambda m: 'Go Away ' + m, Message
...     r['candygram'] = lambda m: 'Hello ' + m, Message
...     for message in r:
...         print message
...
>>> proc = spawn(proc_func)
>>> proc | 'land shark'
>>> proc | 'candygram'
\end{verbatim}
Running the above code produces the following output:
\begin{verbatim}
Go Away land shark
Hello candygram
\end{verbatim}

The above code uses a rather Erlangy syntax. Here is a more Pythonic version
that does the same:
\begin{verbatim}
>>> import candygram as cg
>>> def shut_door(name):
...     return 'Go Away ' + name
...
>>> def open_door(name):
...     return 'Hello ' + name
...
>>> def proc_func():
...     r = cg.Receiver()
...     r.addHandler('land shark', shut_door, cg.Message)
...     r.addHandler('candygram', open_door, cg.Message)
...     for message in r:
...         print message
...
>>> proc = cg.spawn(proc_func)
>>> proc.send('land shark')
>>> proc.send('candygram')
\end{verbatim}

Lastly, here is an example with more elaborate patterns:
\begin{verbatim}
>>> from candygram import *
>>> def print_string(name, message):
...     msg, process, string = message
...     # 'msg' and 'process' are unused
...     print '%s received: %s' % (name, string)
...
>>> def print_any(name, message):
...     msg, process, prefix, value = message
...     # 'send' and 'process' are unused
...     print '%s received: %s %s' % (name, prefix, value)
...
>>> def proc_func(name):
...     r = Receiver()
...     r['msg', Process, str] = print_string, name, Message
...     r['msg', Process, str, Any] = print_any, name, Message
...     r[Any]  # Ignore any other messages
...     for result in r:
...         pass
...
>>> a = spawn(proc_func, 'A')
>>> b = spawn(proc_func, 'B')
>>> a | ('msg', b, 'Girl Scout cookies')
>>> a | 'plumber?'
>>> a | ('msg', b, 'The meaning of life is:', 42)
\end{verbatim}
Running the above code produces the following output:
\begin{verbatim}
A received: Girl Scout cookies
A received: The meaning of life is: 42
\end{verbatim}



% ############################################################################
\section{FAQ}

\subsection{Why is the package called Candygram?}
The name Candygram is actually an acronym for ``the Candygram Acronym Does Not
Yield a Good Reference to Anything Meaningful.''

\subsection{But wait, doesn't that spell {\sc cadnygram}?}
Yes, you are quite observant. In order to form a compromise with the French
acronym, which is {\sc canydgram}, the official acronym was standardized as
{\sc Candygram}.

\subsection{How do you pronounce Candygram?}
This question produces an outrageous amount of heated debate. Some claim that
it is pronounced with short A's, as in tomato, while others claim that it is
pronounced with long A's, as in potato. Both sides, however, are completely
wrong; the name Candygram is correctly pronounced ``throat warbler mangrove.''



% ############################################################################
\section{Feedback}

Please submit all bug reports, feature requests, etc. to the appropriate tracker
on \ulink{SourceForge.net}{http://sourceforge.net/tracker/?group_id=114295}.

General discussion takes place on the
\email{candygram-discuss@lists.sourceforge.net} mailing list. You can subscribe
to this list by visiting \ulink{this page}
	{http://lists.sourceforge.net/lists/listinfo/candygram-discuss}.



% ############################################################################
\appendix
\section{GNU Free Documentation License}
\label{fdl}
\input{LICENSE.tex}



% ############################################################################
\input{candygram.ind}
\end{document}
