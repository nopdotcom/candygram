\documentclass{howto}
\title{Candygram}
\makeindex
\date{\today}
\author{Michael Hobbs}
\authoraddress{
        Email: \email{mike@hobbshouse.org}
}
\release{1.0 beta 1}
\setshortversion{1.0}

\newcommand{\Erlang}{\ulink{Erlang}{http://www.erlang.org/}}

% PDF output doesn't display '<' or '>' symbols well, unless it is in math mode.
% The math mode graphics generated by latex2html, on the other hand, look awful.
\ifpdf
 	\newcommand{\lessthan}[0]{\begin{math}<\end{math}}
 	\newcommand{\greaterthan}[0]{\begin{math}>\end{math}}
\else
 	\newcommand{\lessthan}[0]{<}
 	\newcommand{\greaterthan}[0]{>}
\fi



\begin{document}

\maketitle

Copyright \copyright\ 2004 Michael Hobbs.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled ``GNU
Free Documentation License''. [\ref{fdl}]

\begin{abstract}
\noindent
Candygram is a Python implementation of \Erlang\ concurrency primitives. Erlang
is widely respected for its elegant built-in facilities for concurrent
programming. This package attempts to emulate those facilities as closely as
possible in Python. Specifically, this package provides functions that allow
developers to send and receive messages between threads using semantics nearly
identical to those in the Erlang language.
\end{abstract}

\tableofcontents



\section{Download}

\ulink{Download}{http://sourceforge.net/project/showfiles.php?group_id=114295}

Documentation is also available in PDF.



\section{Overview}

\begin{notice}[note]
Erlang uses a peculiar terminology in respect to threads. In Erlang parlance,
threads are actually called ``processes''. This terminology is due to a couple
of reasons. First, the Erlang runtime environment is a virtual machine. Second,
because Erlang is a functional language, no state is shared among its threads.
Since the concurrent tasks in an Erlang system run as peers within a single
[virtual] machine and don't share state, they are therefore named ``Processes''.

In order to avoid confusion when using this documentation alongside the Erlang
documentation, the word ``process'' is used instead of ``thread'' throughout the
remainder of this document.
\end{notice}

This package provides an implementation of the following \Erlang\ core
functions:
\begin{itemize}
	\item \function{spawn()}
	\item \function{send()}
	\item \keyword{receive}
	\item \function{link()}
\end{itemize}

These 4 functions form the core of Erlang's concurrency services. The
\function{spawn()} function creates a new process, the \function{send()}
function will send a message to another process, the \keyword{receive} statement
specifies what to do with received messages, and the \function{link()} function
allows one process to monitor the status of another process. In addition to
these core functions, this package also provides implementations of several
supplemental functions such as \function{spawn_link()} and \function{exit()}.

The beauty of the Erlang system is that it is simple and yet powerful.
To communicate with another process, you simply send a message to it.
You need not worry about locks, semaphores, mutexes, etc., in order to
share information among concurrent tasks. Even though message passing is
used typically to implement the producer/consumer model, when it is combined
with the flexibility of the \keyword{receive} statement, it becomes much more
powerful. For example, when using timeouts and selective receives, a process
may easily handle its messages as a state machine, or as a priority queue.

For those who wish to become more familiar with Erlang,
\citetitle[http://www.erlang.org/download/erlang-book-part1.pdf]
{Concurrent Programming in Erlang} provides a very complete introduction. In
particular, this package implements all of the functions described in chapter 5
and sections 7.2, 7.3, and 7.5 of that book.



\section{Receiver Patterns}

\newcommand{\addhandler}{\method{addHandler()}}

Erlang provides pattern matching in its very syntax, which is then used by the
\keyword{receive} statement. Since Python does not provide pattern matching in
its syntax, we must use a slightly different mechanism to match messages. The
first parameter passed to the \method{Receiver.addHandler()} method
[\ref{Receiver}] can be any Python value. The \addhandler\ method uses this
value as a pattern and interprets it in the following way:
\begin{enumerate}
	\item If the value is \constant{candygram.Any}, then any message will match.
	\item If the value is a class object or a type object, then any message that
		\function{isinstance()} of the class or type will match.
	\item If the value is a function or method, then a message will match if the
		function/method returns \constant{True} when called with the message.
	\item If the value is a list or tuple, then a message will match only if it
		is a list or tuple, respectively, and of the same length. Also, each value
		in the sequence is then used as a pattern and the sequence as a whole will
		match only if every pattern in the sequence matches.
	\item If the value is a list or tuple, and the last item in the sequence is
		\constant{candygram.AnyRemaining}, then the above rules apply except that
		the message sequence may be any length that is \greaterthan= len(pattern)-1.
	\item If the value is a dictionary, then a message will match only if it
		is a dictionary that contains all of the same keys as the pattern value.
		Also, each value in the dictionary is then used and a pattern and the
		dictionary as a whole will match only if every pattern in the dictionary
		matches its associated value in the message.
	\item Lastly, any other value is treated as a literal pattern. That is, a
		message will match if it is equal to the given value.
\end{enumerate}

\subsection{Examples}
These rules are best illustrated by example. In the table below, the first
column contains a Python value that is used as a pattern. The second column
contains Python values that would match the pattern and the third column
contains Python values that would not match the pattern.
\begin{tableiii}{l|l|l}{textrm}{Pattern}{Matches}{Non-Matches}
\lineiii{Any}
	{'shark', 13.7, (1, '', lambda: true)}
	{}
\lineiii{'shark'}
	{'shark'}
	{'dolphin', 43, []}
\lineiii{13.7}
	{13.7}
	{'shark', 13.6, \{'A': 14\}}
\lineiii{int}
	{13, 43, 0}
	{'shark', 13.7, []}
\lineiii{str}
	{'shark', '', 'dolphin'}
	{43, 0.9, lambda: true}
\lineiii{lambda x: x \greaterthan\ 20}
	{43, 100, 67.7}
	{13, 0, -67.7}
\lineiii{(str, int)}
	{('shark', 43), ('dolphin', 0)}
	{['shark', 43], ('dolphin', 43, 0.9)}
\lineiii{(str, int, AnyRemaining)}
	{('dolphin', 0), ('dolphin', 43, 0.9)}
	{('dolphin',), (43, 'dolphin')}
\lineiii{[str, 20, lambda x: x \lessthan\ 0]}
	{['shark', 20, -54.76], ['dolphin', 20, -1]}
	{['shark', 21, -6], [20, 20, -1], ['', 20]}
\lineiii{\{'S': int, 19: str\}}
	{\{'S': 3, 19: 'foo'\}, \{'S': -65, 19: 'bar', 'T': 'me'\}}
	{\{'S': 'Charlie', 19: 'foo'\}, \{'S': 3\}}
\end{tableiii}



\section{The \module{candygram} module}

\declaremodule{extension}{candygram}
\modulesynopsis{Erlang concurrency primitives}

The following functions, classes, and constants are exported by the
\module{candygram} module. Since the name \module{candygram} is a bit long, the
module is typically imported in one of the following ways:
\begin{verbatim}
>>> from candygram import *
\end{verbatim}
or
\begin{verbatim}
>>> import candygram as cg
\end{verbatim}


\subsection{Functions}

\begin{funcdesc}{spawn}{func\optional{, args\moreargs}}
Return the \class{Process} instance of a new concurrent process started by
calling the function \var{func} with the \var{args} argument list. When the
function returns, the process terminates. A \code{'badarg'}
\exception{ExitError} is raised if \var{func} is not \function{callable()}.
\end{funcdesc}

\begin{funcdesc}{link}{proc}
Create a link to the process \var{proc}, if there is not such a link already. If
a process attempts to create a link to itself, nothing is done. A
\code{'badarg'} \exception{ExitError} is raised if \var{proc} is not a
\class{Process} instance. A \code{'noproc'} \code{'EXIT'} signal is sent to
calling process if the \var{proc} process is no longer alive.

When a process terminates, an \code{'EXIT'} signal is sent to all of its linked
processes. If a process terminates normally, a \code{'normal'} \code{'EXIT'}
signal is sent to its linked processes.

All links are bidirectional. That is, if process A calls \code{link(B)}, then if
process B terminates, an \code{'EXIT'} signal is sent to process A. Conversely,
if process A terminates, an \code{'EXIT'} signal is likewise sent to process B.

Refer to the \function{processFlag()} function for details about handling
signals.
\end{funcdesc}

\begin{funcdesc}{spawnLink}{func\optional{, args\moreargs}}
This function is identical to the following code being evaluated in an atomic
operation:
\begin{verbatim}
>>> proc = spawn(func, args...)
>>> link(proc)
\end{verbatim}
This function is necessary since the process created might run immediately and
fail before \function{link()} is called. Returns the \class{Process} instance of
the newly created process. A \code{'badarg'} \exception{ExitError} is raised if
\var{func} is not \function{callable()}.
\end{funcdesc}

\begin{funcdesc}{unlink}{proc}
Remove the link, if there is one, from the calling process to another process
given by the \var{proc} argument. The function will not fail if the calling
process is not linked to \var{proc}, or if \var{proc} is not alive. A
\code{'badarg'} \exception{ExitError} is raised if \var{proc} is not a
\class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{isProcessAlive}{proc}
Return \constant{True} if the process is alive, i.e., has not terminated.
Otherwise, return \constant{False}. A \code{'badarg'} \exception{ExitError} is
raised if \var{proc} is not a \class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{self}{}
Return the \class{Process} instance of the calling process.
\end{funcdesc}

\begin{funcdesc}{self_}{}
An alias for the \function{self()} function. This function can be used used in
class methods where \var{self} is already defined.
\end{funcdesc}

\begin{funcdesc}{processes}{}
Return a list of all active processes.
\end{funcdesc}

\begin{funcdesc}{send}{proc, message}
Send the \var{message} to the \var{proc} process and return \var{message}. This
is the same as \var{proc}\code{.send(}\var{message}\code{)}. A \code{'badarg'}
\exception{ExitError} is raised if \var{proc} is not a \class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{exit}{\optional{proc, }reason}
When the \var{proc} argument is not given, this function raises an
\exception{ExitError} with the reason \var{reason}. \var{reason} can be any
value.

When the \var{proc} argument is given, this function sends an \code{'EXIT'}
signal to the process \var{proc}. This is not necessarily the same as sending an
\code{'EXIT'} message to \var{proc}. They are the same if \var{proc} is trapping
exits. However, if \var{proc} is not trapping exits, the \var{proc} process will
exit and propagate the \code{'EXIT'} signal in turn to its linked processes.

If the \var{reason} is the string \code{'kill'}, for example
\code{exit(proc, 'kill')}, an untrappable \code{'EXIT'} signal will be sent to
the process. In other words, the \var{proc} process will be unconditionally
killed.

Refer to the \function{processFlag()} function for details about trapping exits.
\end{funcdesc}

\begin{funcdesc}{processFlag}{flag, option}
Set the given \var{flag} for the process which calls this function.
Returns the old value of the flag. A \code{'badarg'} \exception{ExitError} is
raised if \var{flag} is not a recognized flag value, or if \var{option} is not
a recognized value for \var{flag}.

Currently, the only recognized flag value is \code{'trap_exit'}. When
\code{'trap_exit'} is set to \constant{True}, \code{'EXIT'} signals arriving to
a process are converted to \code{('EXIT', from, reason)} messages, which can be
received as ordinary messages. If \code{'trap_exit'} is set to \constant{False},
the process exits if it receives an \code{'EXIT'} signal other than
\code{'normal'} and the \code{'EXIT'} signal is propagated to its linked
processes. Application processes should normally not trap exits.
\end{funcdesc}



\subsection{Process Objects}

\begin{classdesc}{Process}{}
Represents a concurrent process. A \class{Process} is never created via its
constructor. All processes are created via the \function{spawn()} and
\function{spawnLink()} functions instead.

\begin{methoddesc}{isProcessAlive}{}
Return \constant{True} if the process is alive, i.e., has not terminated.
Otherwise, return \constant{False}.
\end{methoddesc}

\begin{methoddesc}{isAlive}{}
An alias for the \method{isProcessAlive()} method. (The word ``process'' is
redundant in a method name in the \class{Process} class.)
\end{methoddesc}

\begin{methoddesc}{send}{message}
Send the \var{message} to this process and return \var{message}. Typically, a
routine running in a separate process calls this method to place the given
\var{message} into this process's mailbox. The message may then be picked up
by a \class{Receiver} that is operating in this process.

Sending a message is an asynchronous operation so the \method{send()} call will
not wait for the message to be received by a \class{Receiver}. Even if this
process has already terminated, the system will not notify the sender. Messages
are always delivered, and always in the same order they were sent.
\end{methoddesc}

\begin{methoddesc}{__or__}{message}
An alias for the \method{send()} method. The OR operator, `|', is aliased to
the \method{send()} method so that messages can be sent using a more Erlangy
syntax. In Erlang, messages are sent using the `!' primitive. For example:
\begin{verbatim}
>>> proc | ('knock-knock', 'candygram')
\end{verbatim}
\end{methoddesc}

\end{classdesc}



\subsection{Receiver Objects}
\label{Receiver}

\begin{classdesc}{Receiver}{}
% TODO: review documentation for send() and make sure this discription ties-in
% well with that documentation.
Some stuff about Receiver.

\begin{methoddesc}{addHandler}{pattern\optional{, func\optional{, \moreargs}}}

Some stuff about addHandler

When the \method{Receiver.receive()} method is called, the \class{Receiver}
object compares the first message in its mailbox with each pattern, in the order
that the handlers were added via the \addhandler\ method. If any pattern matches
the message, it will call the associated function and return its result.

If extra parameters are supplied in the call to \addhandler\ after the handler
function, those parameters are passed to the handler function when it is called.
If any of these function parameters is \constant{candygram.Message}, then the
parameter is replaced with the message that was received.
\end{methoddesc}

\end{classdesc}



\subsection{Constants}

\begin{datadesc}{Any}
\end{datadesc}

\begin{datadesc}{AnyRemaining}
\end{datadesc}

\begin{datadesc}{Message}
\end{datadesc}



\subsection{Exceptions}

\begin{excdesc}{ExitError}
\end{excdesc}



\section{Examples}

\begin{verbatim}
>>> from candygram import *
>>> r = Receiver()
>>> def open_door():
...     print 'Hello.'
...
>>> def shut_door():
...     print 'Go Away!'
...
>>> r.addHandler('shark', shut_door)
>>> r.addHandler('candygram', open_door)
>>> r.receive()
\end{verbatim}


\section{FAQ}

\subsection{Why is the package called Candygram?}
The name Candygram is actually an acronym for ``the Candygram Acronym Does Not
Yield a Good Reference to Anything Meaningful.''

\subsection{But wait, doesn't that spell {\sc cadnygram}?}
Yes, you are quite observant. In order to form a compromise with the French
acronym, which is {\sc canydgram}, the official acronym was standardized as
{\sc Candygram}.

\subsection{How do you pronounce Candygram?}
This question produces an outrageous amount of heated debate. Some claim that
it is pronounced with short A's, as in tomato, while others claim that it is
pronounced with long A's, as in potato. Both sides, however, are completely
wrong; the name Candygram is correctly pronounced ``throat warbler mangrove.''



\section{Feedback}

Please submit bugs here



\appendix
\section{GNU Free Documentation License}
\label{fdl}
\input{LICENSE.tex}



\input{candygram.ind}
\end{document}
