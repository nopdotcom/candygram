\documentclass{howto}
\title{Candygram}
\makeindex
\date{\today}
\author{Michael Hobbs}
\authoraddress{
        Email: \email{mike@hobbshouse.org}
}
\release{1.0 beta 2}
\setshortversion{1.0}

\newcommand{\Erlang}{\ulink{Erlang}{http://www.erlang.org/}}
\newcommand{\erlangbook}{\citetitle[http://www.erlang.org/download/erlang-book-part1.pdf]{Concurrent Programming in Erlang}}

% PDF output doesn't display some symbols well, unless it is in math mode.
% The math mode graphics generated by latex2html, on the other hand, look awful.
\ifpdf
 	\newcommand{\lessthan}[0]{\begin{math}<\end{math}}
 	\newcommand{\greaterthan}[0]{\begin{math}>\end{math}}
 	\newcommand{\pipe}[0]{\begin{math}|\end{math}}
\else
 	\newcommand{\lessthan}[0]{<}
 	\newcommand{\greaterthan}[0]{>}
 	\newcommand{\pipe}[0]{|}
\fi



\begin{document}

\maketitle

Copyright \copyright\ 2004 Michael Hobbs.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled ``GNU
Free Documentation License''.

\begin{abstract}
\noindent
Candygram is a Python implementation of \Erlang\ concurrency primitives. Erlang
is widely respected for its elegant built-in facilities for concurrent
programming. This package attempts to emulate those facilities as closely as
possible in Python. With Candygram, developers can send and receive messages
between threads using semantics nearly identical to those in the Erlang
language.
\end{abstract}

\tableofcontents



% ############################################################################
\section{Download And Install}

You can download all available versions of Candygram from
\ulink{SourceForge.net}
	{http://sourceforge.net/project/showfiles.php?group_id=114295}. The current
stable release, as of this writing, is \version. You can also download this
document in PDF format from the link above.

To install, uncompress the zip or tar file, \program{cd} into the directory, and
run:
\begin{verbatim}
python setup.py install
\end{verbatim}

Windows users can just download the installer program and run it.



% ############################################################################
\section{Overview}
\label{overview}

\begin{notice}[note]
Erlang uses a peculiar terminology in respect to threads. In Erlang parlance,
threads are called ``processes''. This terminology is due to a couple of
reasons. First, the Erlang runtime environment is a virtual machine. Second,
because Erlang is a functional language, no state is shared among its threads.
Since the concurrent tasks in an Erlang system run as top-level peers within a
single [virtual] machine and don't share state, they are therefore named
``Processes''.

To avoid confusion when using this document alongside the Erlang documentation,
the remainder of this document uses the word ``process'' instead of ``thread''.
You are free, however, to pronounce the word ``process'' however you wish.
\end{notice}

This package provides an implementation of the following \Erlang\ core
functions:
\begin{itemize}
	\item \function{spawn()}
	\item \function{send()}
	\item \keyword{receive}
	\item \function{link()}
\end{itemize}

These 4 functions form the core of Erlang's concurrency services. The
\function{spawn()} function creates a new process, the \function{send()}
function sends a message to another process, the \keyword{receive} statement
specifies what to do with received messages, and the \function{link()} function
allows one process to monitor the status of another process. In addition to
these core functions, this package also provides implementations of several
supplemental functions such as \function{spawn_link()} and \function{exit()}.

The beauty of the Erlang system is that it is simple and yet powerful. To
communicate with another process, you simply send a message to it. You do not
need to worry about locks, semaphores, mutexes, etc. to share information among
concurrent tasks. Developers mostly use message passing only to implement the
producer/consumer model. When you combine message passing with the flexibility
of the \keyword{receive} statement, however, it becomes much more powerful. For
example, by using timeouts and receive patterns, a process may easily handle its
messages as a state machine, or as a priority queue.

For those who wish to become more familiar with Erlang, \erlangbook\ provides a
very complete introduction. In particular, this package implements all of the
functions described in chapter 5 and sections 7.2, 7.3, and 7.5 of that book.



% ############################################################################
\section{Receiver Patterns}
\label{patterns}
\index{patterns}

\newcommand{\addhandler}{\method{addHandler()}}

Erlang provides pattern matching in its very syntax, which the \keyword{receive}
statement uses to its advantage. Since Python does not provide pattern matching
in its syntax, we must use a slightly different mechanism to match messages. The
first argument passed to the \method{Receiver.addHandler()} method can be any
Python value. The \addhandler\ method uses this value as a pattern and
interprets it in the following way:
\begin{enumerate}
	\item If the value is the constant, \constant{candygram.Any}, then any message
		will match.
	\item If the value is a type object or a class, then any message that
		\function{isinstance()} of the type or class will match.
	\item If the value is \function{callable()}, then a message will match if the
		function/method returns \constant{True} when called with the message.
	\item If the value is a tuple, then a message will match only if it	is a tuple
		of the same length. Also, each value in the tuple is used as a pattern and
		the tuple as a whole will match only if every sub-pattern in the tuple
		matches its associated value in the message.
	\item If the value is a list, then the same rule for tuples applies, except
		for the last sub-pattern. The last sub-pattern in the list can match zero or
		more values in the message. That is, the length of the message may be
		\greaterthan= len(pattern)-1 as long as all excess values match the last
		sub-pattern.
	\item If the value is a dictionary, then a message will match only if it
		is a dictionary that contains all of the same keys as the pattern value.
		Also, each value in the dictionary is used as a pattern and the
		dictionary as a whole will match only if every pattern in the dictionary
		matches its associated value in the message.
	\item Lastly, \addhandler\ treats any other value as a literal pattern. That
		is, a message will match if it is equal to the given value.
\end{enumerate}

\subsection{Examples}
Let's illustrate these rules by example.\footnote
{Do not use all of these patterns at home. These are highly trained stunt
patterns and are displayed here for demonstration purposes only. Specifically,
you should rarely ever use more than one sub-pattern in a list pattern, nor
should you ever use more than one type of key in a single dictionary.}
 In the table below, the first column contains a Python value that is used as a
pattern. The second column contains Python values that match the pattern and the
third column contains Python values that do not match the pattern.
\begin{tableiii}{l|l|l}{textrm}{Pattern}{Matches}{Non-Matches}
\lineiii{Any}
	{'text', 13.7, (1, '', lambda: true)}
	{}
\lineiii{'land shark'}
	{'land shark'}
	{'dolphin', 42, []}
\lineiii{13.7}
	{13.7}
	{'text', 13.6, \{'A': 14\}}
\lineiii{int}
	{13, 42, 0}
	{'text', 13.7, []}
\lineiii{str}
	{'plumber', ''}
	{42, 0.9, lambda: True}
\lineiii{lambda x: x \greaterthan\ 20}
	{42, 100, 67.7}
	{13, 0, -67.7}
\lineiii{(str, int)}
	{('shark', 42), ('dolphin', 0)}
	{['shark', 42], ('dolphin', 42, 0)}
\lineiii{(str, 20, lambda x: x \lessthan\ 0)}
	{('shark', 20, -54.76), ('dolphin', 20, -1)}
	{('shark', 21, -6), (20, 20, -1), ('', 20)}
\lineiii{['A', str, str]}
	{['A', 'B', 'C', 'D'], ['A', 'B']}
	{['C', 'B', 'A'], ['A']}
\lineiii{[str, int]}
	{['dolphin', 42, 0], ['shark']}
	{[42, 0], ['dolphin', 42, 'shark']}
\lineiii{[Any]}
	{['dolphin', 42, 0.9], []}
	{('dolphin', 42, 0.9), 'shark'}
\lineiii{\{'S': int, 19: str\}}
	{\{'S': 3, 19: 'foo'\}, \{'S': -65, 19: 'bar', 'T': 'me'\}}
	{\{'S': 'Charlie', 19: 'foo'\}, \{'S': 3\}}
\end{tableiii}



% ############################################################################
\section{The \module{candygram} module}

\declaremodule{extension}{candygram}
\modulesynopsis{Erlang concurrency primitives}

The \module{candygram} module exports the following functions, classes,
constants, and exceptions. Since the name \module{candygram} is a bit long, you
would typically import the module in one of the following ways:
\begin{verbatim}
>>> from candygram import *
\end{verbatim}
or
\begin{verbatim}
>>> import candygram as cg
\end{verbatim}



% ----------------------------------------------------------------------------
\subsection{Functions}

\begin{funcdesc}{spawn}{func\optional{, args\moreargs}\optional{, _processClass=Process}}
Create a new concurrent process by calling the function \var{func} with the
\var{args} argument list and return the resulting \class{Process} instance.
When the function \var{func} returns, the process terminates. Raises a
\code{'badarg'} \exception{ExitError} if \var{func} is not
\function{callable()}.

If you define a subclass of \class{Process}, you can instruct the
\function{spawn()} function to create an instance of that class by passing
the class with the optional \var{_processClass} keyword argument.
\end{funcdesc}

\begin{funcdesc}{link}{proc}
Create a link to the process \var{proc}, if there is not such a link already. If
a process attempts to create a link to itself, nothing is done. Raises a
\code{'badarg'} \exception{ExitError} if \var{proc} is not a \class{Process}
instance. Sends a \code{'noproc'} \code{'EXIT'} signal to calling process if the
\var{proc} process is no longer alive.

When a process terminates, it sends an \code{'EXIT'} signal is to all of its
linked processes. If a process terminates normally, it sends a \code{'normal'}
\code{'EXIT'} signal to its linked processes.

All links are bidirectional. That is, if process A calls \code{link(B)}, then if
process B terminates, it sends an \code{'EXIT'} signal to process A. Conversely,
if process A terminates, it likewise sends an \code{'EXIT'} signal to process B.

Refer to the \function{processFlag()} function for details about handling
signals.
\end{funcdesc}

\begin{funcdesc}{spawnLink}{func\optional{, args\moreargs}\optional{, _processClass=Process}}
This function is identical to the following code being evaluated in an atomic
operation:
\begin{verbatim}
>>> proc = spawn(func, args...)
>>> link(proc)
\end{verbatim}
This function is necessary since the process created might run immediately and
fail before \function{link()} is called. Returns the \class{Process} instance of
the newly created process. Raises a \code{'badarg'} \exception{ExitError} if
\var{func} is not \function{callable()}.

If you define a subclass of \class{Process}, you can instruct the
\function{spawnLink()} function to create an instance of that class by passing
the class with the optional \var{_processClass} keyword argument.
\end{funcdesc}

\begin{funcdesc}{unlink}{proc}
Remove the link, if there is one, from the calling process to another process
given by the \var{proc} argument. The function does not fail if the calling
process is not linked to \var{proc}, or if \var{proc} is not alive. Raises a
\code{'badarg'} \exception{ExitError} if \var{proc} is not a \class{Process}
instance.
\end{funcdesc}

\begin{funcdesc}{isProcessAlive}{proc}
Return \constant{True} if the process is alive, i.e., has not terminated.
Otherwise, return \constant{False}. Raises a \code{'badarg'}
\exception{ExitError} if \var{proc} is not a \class{Process} instance.
\end{funcdesc}

\begin{funcdesc}{self}{}
Return the \class{Process} instance of the calling process.
\end{funcdesc}

\begin{funcdesc}{self_}{}
An alias for the \function{self()} function. You can use this function in class
methods where \var{self} is already defined.
\end{funcdesc}

\begin{funcdesc}{processes}{}
Return a list of all active processes.
\end{funcdesc}

\begin{funcdesc}{send}{proc, message}
Send the \var{message} to the \var{proc} process and return \var{message}. This
is the same as \var{proc}\code{.send(}\var{message}\code{)}. Raises a
\code{'badarg'} \exception{ExitError} if \var{proc} is not a \class{Process}
instance.
\end{funcdesc}

\begin{funcdesc}{exit}{\optional{proc, }reason}
When the \var{proc} argument is not given, this function raises an
\exception{ExitError} with the reason \var{reason}. \var{reason} can be any
value.

When the \var{proc} argument is given, this function sends an \code{'EXIT'}
signal to the process \var{proc}. This is not necessarily the same as sending an
\code{'EXIT'} message to \var{proc}. They are the same if \var{proc} is trapping
exits. If \var{proc} is not trapping exits, however, the \var{proc} process
terminates and propagates the \code{'EXIT'} signal in turn to its linked
processes.

If the \var{reason} is the string \code{'kill'}, an untrappable \code{'EXIT'}
signal is sent to the process. In other words, the \var{proc} process is
unconditionally killed.

Refer to the \function{processFlag()} function for details about trapping exits.
\end{funcdesc}

\begin{funcdesc}{processFlag}{flag, option}
Set the given \var{flag} for the calling process. Returns the old value of the
flag. Raises a \code{'badarg'} \exception{ExitError} if \var{flag} is not a
recognized flag value, or if \var{option} is not a recognized value for
\var{flag}.

Currently, \code{'trap_exit'} is the only recognized flag value. When
\code{'trap_exit'} is set to \constant{True}, \code{'EXIT'} signals arriving to
a process are converted to \code{('EXIT', from, reason)} messages, which can be
received as ordinary messages. If \code{'trap_exit'} is set to \constant{False},
the process exits if it receives an \code{'EXIT'} signal other than
\code{'normal'} and propagates the \code{'EXIT'} signal to its linked processes.
Application processes should normally not trap exits.
\end{funcdesc}



% ----------------------------------------------------------------------------
\subsection{Process Objects}

\begin{classdesc}{Process}{}
Represents a concurrent process. A \class{Process} is never created via its
constructor. The \function{spawn()} and \function{spawnLink()} functions create
all processes.

\begin{methoddesc}{isProcessAlive}{}
Return \constant{True} if the process is alive, i.e., has not terminated.
Otherwise, return \constant{False}.
\end{methoddesc}

\begin{methoddesc}{isAlive}{}
An alias for the \method{isProcessAlive()} method. (The word ``process'' is
redundant in a method name when the method is a member of the \class{Process}
class.)
\end{methoddesc}

\begin{methoddesc}{send}{message}
Send the \var{message} to this process and return \var{message}. A routine
running in a separate process calls this method to place the given
\var{message} into this process's mailbox. A \class{Receiver} that is operating
in this process may then pick up the message.

Sending a message is an asynchronous operation so the \method{send()} call does
not wait for a \class{Receiver} to retrieve the message. Even if this process
has already terminated, the system does not notify the sender. Messages are
always delivered, and always in the same order they were sent.
\end{methoddesc}

\begin{methoddesc}{__or__}{message}
\opindex{|}
An alias for the \method{send()} method. The OR operator, `\pipe', is an alias
to the \method{send()} method so that developers can use a more Erlangy syntax
to send messages. In Erlang, the `!' primitive sends messages. For example:
\begin{verbatim}
>>> proc | ('knock-knock', 'candygram')
\end{verbatim}
\end{methoddesc}

\end{classdesc}



% ----------------------------------------------------------------------------
\subsection{Receiver Objects}
\label{Receiver}

\begin{classdesc}{Receiver}{}
Retrieves messages from a process's mailbox. Every process maintains a mailbox,
which contains messages that have been sent to it via the \method{send()}
method. To retrieve the messages out of the mailbox, a process must use a
\class{Receiver} object. Like the \keyword{receive} statement in Erlang, a
\class{Receiver} object compares an incoming message against multiple patterns
and invokes the callback function that is associated with the first matching
pattern. Refer to section \ref{patterns} for details about how to specify
message patterns.

\begin{methoddesc}{addHandler}{pattern\optional{, func\optional{, args\moreargs}}}
Register a handler function \var{func} for the \var{pattern}. The
\method{receive()} method calls the \var{func} with the \var{args} argument
list when it receives a message that matches \var{pattern}. When a handler
function \var{func} is not specified, the \method{receive()} method removes any
matching message from the mailbox and does nothing more with it. Refer to
section \ref{patterns} for details about how to specify message patterns.
Returns a handler reference that can be used with the \method{removeHandler()}
method. Raises a \code{'badarg'} \exception{ExitError} if \var{func} is not
\function{callable()}.

If any of the \var{args} arguments is \constant{candygram.Message}, then the
\method{receive()} method replaces that argument with the matching message when
it invokes \var{func}.

Refer to the \method{receive()} documentation for details about the
mechanism by which it invokes the handlers.
\end{methoddesc}

\begin{methoddesc}{__setitem__}{pattern, funcWithArgs}
\opindex{[]}
An alias for the \method{addHandler()} method. If \var{funcWithArgs} is a tuple,
then this method sends the first element in the tuple as the \var{func}
parameter to \method{addHandler()} and the remaining as the \var{args}. If
\var{funcWithArgs} is not a tuple, then this method assumes it to be a handler
function and sends it as the \var{func} parameter to \method{addHandler()}.

\method{__setitem__()} is an alias to the \method{addHandler()} method so that
developers can use a more Erlangy syntax to specify handlers. In Erlang, the
``\var{pattern} -\greaterthan\ \var{func}'' syntax specifies pattern guards. For
example:
\begin{verbatim}
>>> r = Receiver()
>>> r['knock-knock', 'candygram'] = answer, 'From whom?'
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}{__getitem__}{pattern}
\opindex{[]}
An alias for the \method{addHandler()} method. This method calls
\method{addHandler()} without a \var{func} parameter.

\method{__getitem__()} is an alias to the \method{addHandler()} method so that
developers can use a more Erlangy syntax to specify handlers. In Erlang, the
``\var{pattern} -\greaterthan\ \var{func}'' syntax specifies pattern guards. For
example:
\begin{verbatim}
>>> r = Receiver()
>>> r['knock-knock', 'shark']  # ignore sharks
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}{addHandlers}{receiver}
Register all handler functions in \var{receiver} with this \class{Receiver}
object. This method adds all of the patterns and handler functions that have
been added to the given \var{receiver} to this receiver, in the same order. You
can use this method to make copies of \class{Receiver} objects. Returns a list
of handler references that can be used with the \method{removeHandler()} method.
Raises a \code{'badarg'} \exception{ExitError} if \var{receiver} is not a
\class{Receiver} instance.
\end{methoddesc}

\begin{methoddesc}{removeHandler}{handlerReference}
Remove a handler function. The \var{handlerReference} must be a value returned
by either the \method{addHandler()} or the \method{addHandlers()} method. Since
all handler references are unique, this method removes exactly one handler
function from the \class{Receiver}. Raises a \code{'badarg'}
\exception{ExitError} if \var{handlerReference} is not a proper reference, or if
it refers to a handler function that is not in the \class{Receiver}.
\end{methoddesc}

\begin{methoddesc}{after}{timeout\optional{, func\optional{, args\moreargs}}}
Register a timeout handler function \var{func}. The \method{receive()} method
calls the \var{func} with the \var{args} argument list when it does not receive
a matching message within \var{timeout} milliseconds. Raises a \code{'badarg'}
\exception{ExitError} if \var{func} is not \function{callable()} or if
\var{timeout} is not an integer. Raises an \exception{AssertionError} if the
\method{after()} method has already been invoked.

If the \method{receive()} method does not find a matching message within
\var{timeout} milliseconds, it invokes \var{func} with \var{args} and returns
the result. When a handler function \var{func} is not specified, the
\method{receive()} method returns \constant{None} if it times out.

None of the \var{args} arguments should be \constant{candygram.Message}, since
there is no message to pass when a timeout occurs.
\end{methoddesc}

\begin{methoddesc}{receive}{\optional{timeout\optional{, func\optional{, args\moreargs}}}}
Find a matching message in the process's mailbox, invoke the related handler
function, and return the result. The \class{Receiver} object compares the first
message in the process's mailbox with each of its registered patterns, in the
order that the patterns were added via the \method{addHandler()} method. If any
pattern matches the message, this method removes the message from the mailbox,
calls the associated handler function, and returns its result. If the matching
pattern does not have a handler function associated with it, this method returns
\constant{None}. If no pattern matches the message, this method leaves the
message in the mailbox, skips to the next message in the mailbox, and compares
it with each of the patterns. It continues on through each of the messages in
the mailbox until a match is found.

If no message matches any of the patterns, or if the mailbox is empty, this
method blocks until the process receives a message that does match one of the
patterns, or until the given \var{timeout} has elapsed. If no \var{timeout} is
specified, this method blocks indefinitely. If a \var{timeout} is specified, it
is equivalent to calling \method{after(\var{timeout}, \var{func}, \var{args})}
just prior to \method{receive()}. Raises a \code{'badarg'}
\exception{ExitError} if \var{func} is not \function{callable()} or if
\var{timeout} is not an integer. Also raises an \exception{AssertionError} if a
\var{timeout} is specified and the \method{after()} method has already been
invoked.
\end{methoddesc}

\begin{methoddesc}{__call__}{\optional{timeout\optional{, func\optional{, args\moreargs}}}}
\opindex{()}
An alias for the \method{receive()} method. \method{__call__()} is an alias to
the \method{receive()} method so that developers can use a shortened, more
Erlangy syntax with \class{Receiver}s. For example:
\begin{verbatim}
>>> def convert():
...     r = Receiver()
...     r['one'] = lambda: 1
...     r['two'] = lambda: 2
...     r['three'] = lambda: 3
...     return r()
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}{__iter__}{}
Return an iterator that repeatedly invokes \method{receive()}. Candygram code
often uses the following idiom:
\begin{verbatim}
... while True:
...     result = receiver.receive()
...     # do whatever with the result...
\end{verbatim}
With an iterator, you can spell the code above like this instead:
\begin{verbatim}
... for result in receiver:
...     # do whatever with the result...
\end{verbatim}
\end{methoddesc}

\end{classdesc}



% ----------------------------------------------------------------------------
\subsection{Constants}

\begin{datadesc}{Any}
When used in a pattern, the \constant{Any} constant will match any value.
\end{datadesc}

\begin{datadesc}{Message}
When used as a function argument in \method{Receiver.addHandler()}, the
\method{Receiver.receive()} method replaces the argument with the matching
message when it invokes the handler function.
\end{datadesc}



% ----------------------------------------------------------------------------
\subsection{Exceptions}

\begin{excdesc}{ExitError}
Represents \code{'EXIT'} errors from Erlang. If an Erlang function can
cause a failure under certain circumstances, then the corresponding Candygram
function raises an \exception{ExitError} under the same circumstances.

A process also raises an \exception{ExitError} in all of its linked processes
if it terminates for a reason other than \code{'normal'}.

\begin{notice}[note]
When a process terminates with a reason other than \code{'normal'}, it does not
immediately raise an \exception{ExitError} in all linked processes. Candygram
defers the \exception{ExitError} instead, and raises it the next time one of its
functions or methods is called. (Python does not allow you to unconditionally
interrupt a separate thread.)
\end{notice}

\begin{memberdesc}{reason}
Specifies the reason why the \exception{ExitError} was raised. Can be any value.
\end{memberdesc}

\begin{memberdesc}{proc}
The process that originally caused the \exception{ExitError}.
\end{memberdesc}

\end{excdesc}



% ############################################################################
\section{Examples}
There is a directory named \file{examples} within every distribution of
Candygram. This directory contains the Candygram equivalents of all the sample
programs found in chapter 5 and sections 7.2, 7.3, and 7.5 of \erlangbook. The
files named \file{program_X.X.py} are direct translations of the Erlang
programs. The files named \file{program_X.X_alt.py} are alternate, more liberal
translations that use more Pythonic idioms. \note{Since the CPython interpreter
does not perform tail-call optimization, the tail-recursive style of the direct
translations is not a recommended practice.}

The \file{examples} directory also contains a few other modules that demonstrate
how you can use Candygram to perform some handy functions.

If you are not already familiar with Erlang, the best way to become familiar
with Candygram is to read chapter 5 in \erlangbook\ and follow along using the
example programs located in the \file{examples} directory. If you are already
familiar with Erlang, here are a few code snippets to give you a taste of
Candygram.

\begin{verbatim}
>>> from candygram import *
>>> import time
>>> def proc_func():
...     r = Receiver()
...     r['land shark'] = lambda m: 'Go Away ' + m, Message
...     r['candygram'] = lambda m: 'Hello ' + m, Message
...     for message in r:
...         print message
...
>>> proc = spawn(proc_func)
>>> proc | 'land shark'
>>> proc | 'candygram'
>>> # Give the proc a chance to print its messages before termination:
... time.sleep(1)
\end{verbatim}
Running the code above produces the following output:
\begin{verbatim}
Go Away land shark
Hello candygram
\end{verbatim}

\begin{notice}[note]
If this code is run as a script, the Python interpreter will exit after the last
line is evaluated, killing any spawned processes. That is why the last line is
a call to the \function{sleep()} function, so that the spawned process has an
opportunity to print its messages before the interpreter exits and kills it.
\end{notice}

The code above uses a rather Erlangy syntax. Here is a more Pythonic version
that does the same:
\begin{verbatim}
>>> import candygram as cg
>>> import time
>>> def proc_func():
...     r = cg.Receiver()
...     r.addHandler('land shark', shut_door, cg.Message)
...     r.addHandler('candygram', open_door, cg.Message)
...     for message in r:
...         print message
...
>>> def shut_door(name):
...     return 'Go Away ' + name
...
>>> def open_door(name):
...     return 'Hello ' + name
...
>>> proc = cg.spawn(proc_func)
>>> proc.send('land shark')
>>> proc.send('candygram')
>>> # Give the proc a chance to print its messages before termination:
... time.sleep(1)
\end{verbatim}

Lastly, here is an example with more elaborate patterns:
\begin{verbatim}
>>> from candygram import *
>>> import time
>>> def proc_func(name):
...     r = Receiver()
...     r['msg', Process, str] = print_string, name, Message
...     r['msg', Process, str, Any] = print_any, name, Message
...     r[Any]  # Ignore any other messages
...     for result in r:
...         pass
...
>>> def print_string(name, message):
...     msg, process, string = message
...     # 'msg' and 'process' are unused
...     print '%s received: %s' % (name, string)
...
>>> def print_any(name, message):
...     msg, process, prefix, value = message
...     # 'msg' and 'process' are unused
...     print '%s received: %s %s' % (name, prefix, value)
...
>>> a = spawn(proc_func, 'A')
>>> b = spawn(proc_func, 'B')
>>> a | ('msg', b, 'Girl Scout cookies')
>>> a | 'plumber?'
>>> a | ('msg', b, 'The meaning of life is:', 42)
>>> # Give the proc a chance to print its messages before termination:
... time.sleep(1)
\end{verbatim}
Running the code above produces the following output:
\begin{verbatim}
A received: Girl Scout cookies
A received: The meaning of life is: 42
\end{verbatim}



% ############################################################################
\section{FAQ}

\subsection{Why is the package named Candygram?}
The name Candygram is actually an acronym for ``the Candygram Acronym Does Not
Yield a Good Reference to Anything Meaningful.''

\subsection{But wait, doesn't that spell {\sc cadnygram}?}
Yes, you are quite observant. In order to form a compromise with the French
acronym, which is {\sc canydgram}, the Candygram committee standardized the
official acronym as {\sc Candygram}.

\subsection{How do you pronounce Candygram?}
This question produces an outrageous amount of heated debate. Some claim that
you pronounce it with short A's, as in tomato, while others claim that you
pronounce it with long A's, as in potato. Both sides, however, are completely
wrong; the correct pronunciation for Candygram is ``throat warbler mangrove.''

\subsection{Underneath it all, does the \function{spawn()} function create a
process, a thread, or a microthread?}
The short answer is that it creates a thread. In Erlang, the \function{spawn()}
function creates a microthread but calls it a ``process''. Since Python does not
yet support microthreads, the Candygram \function{spawn()} function creates a
standard thread instead and likewise calls it a ``process''. Despite the
terminology, no new operating system processes are ever created. Refer to the
overview in section \ref{overview} for further explanation about the
terminology.

\subsection{How many processes can I \function{spawn()}?}
Since Candygram's \function{spawn()} function creates a new thread, it depends
on how many threads your operating system can reliably handle. Most operating
systems can comfortably handle several dozen threads.

Future versions of Candygram may support microthreads, which would allow you to
spawn thousands of processes.



% ############################################################################
\section{Feedback}

Please submit all bug reports, feature requests, etc. to the appropriate tracker
on \ulink{SourceForge.net}{http://sourceforge.net/tracker/?group_id=114295}.

General discussion takes place on the
\email{candygram-discuss@lists.sourceforge.net} mailing list. You can subscribe
to this list by visiting \ulink{this page}
	{http://lists.sourceforge.net/lists/listinfo/candygram-discuss}.



% ############################################################################
\appendix
\section{GNU Free Documentation License}
\label{fdl}
\input{LICENSE.tex}



% ############################################################################
\input{candygram.ind}
\end{document}
